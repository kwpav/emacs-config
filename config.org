#+TITLE: Emacs Config
#+DESCRIPTION: My personal Emacs configuration.

* About
This is my personal Emacs configuration using [[https://github.com/kwpav/basemacs][basemacs]]  at its core, [[https://github.com/emacs-evil/evil][Evil]] for editing, and [[https://github.com/joaotavora/eglot][Eglot]] (formerly [[https://emacs-lsp.github.io/lsp-mode/][LSP Mode]]) for coding. It is essentially cobbled together from bits and pieces of other configs I have found online. I have been tweaking it (and will probably continue to tweak it) for several years now.

It is a "Literate" config, where prose and code live together in harmony... what this basically means is that configuration code contained in this Org file, along with some text that describes what it's doing.
** How it Works
As with =basemacs=, this is as a literate config using Org mode, and all configuration is done (mostly) with =use-package=.  The code here is tangled using =org-babel-tangle=, it creates =init.el= and various "modules" in the =lisp/= directory.
* Startup
Let's get everything setup!
#+begin_src emacs-lisp :lexical t :tangle init.el
  ;;; init.el --- -*- lexical-binding: t no-byte-compile: t -*-
#+end_src

Add the =lisp/= directory to the =load-path= so we can load =basemacs-core=, modules, and any other custom lisp code.
#+begin_src emacs-lisp :lexical t :tangle init.el
  (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
#+end_src

Load the base config. This gives us =use-package= (along with some other handy packages) and some sane defaults to start with.
#+begin_src emacs-lisp :lexical t :tangle init.el
  (require 'basemacs-core)
#+end_src

Set up the leader keys for =general.el=.
#+begin_src emacs-lisp :lexical t :tangle init.el
  (use-package basemacs-core
    :custom
    (basemacs-leader "SPC")
    (basemacs-local-leader "SPC m"))
#+end_src
* Modules
Here is where the magic happens. Let's load some modules!
#+begin_src emacs-lisp :lexical t :tangle init.el
  ;; emacs
  (require 'kpav-defaults)
  (require 'kpav-system)
  (require 'kpav-evil)
  (require 'kpav-keys)
  (require 'kpav-narrowing)
  (require 'kpav-org)
  (require 'kpav-ui)
  (require 'kpav-windows-and-buffers)
  ;; tools
  (require 'kpav-project)
  (require 'kpav-git)
  (require 'kpav-vterm)
  (require 'kpav-docker)
  ;; code
  (require 'kpav-code)
  (require 'kpav-php)
  (require 'kpav-elisp)
  (require 'kpav-clojure)
  (require 'kpav-common-lisp)
  (require 'kpav-js)
  (require 'kpav-c)
  (require 'kpav-yaml)
  (require 'kpav-grpc)
  (require 'kpav-graphql)
#+end_src

All system specific configuration is done in =lisp/kpav-local.el=. This loads that file if it exists.
#+begin_src emacs-lisp :lexical t :tangle init.el
  (defconst kpav-local-file (expand-file-name "lisp/kpav-local.el" user-emacs-directory))

  (when (file-exists-p kpav-local-file)
    (load kpav-local-file))
#+end_src

This approach requires a bit more code than having this file just tangle to =init.el=, but I like the ability to easily turn on/off and change the order of things for tinkering and debugging purposes.
* Emacs
Things that modify Emacs itself.
** Opininionated Defaults
Some of my more "opinionated" default settings.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-defaults.el
  ;;; kpav-defaults.el --- -*- lexical-binding: t -*-
#+end_src
*** Start Screen
Display the =*scratch*= buffer at startup instead of the dashboard.
#+begin_src emacs-lisp :tangle lisp/kpav-defaults.el
  (use-package emacs
    :straight (:type built-in)
    :custom
    (inhibit-startup-screen t))
#+end_src

*** Pair Matching
Insert matching pairs for things like parens, brackets, quotes, etc. Use it in programming and org modes.
#+begin_src emacs-lisp :tangle lisp/kpav-defaults.el
  (use-package elec-pair
    :straight (:type built-in)
    :gfhook
    ('(prog-mode-hook org-mode-hook) #'electric-pair-mode))
#+end_src

Highlight paren when the cursor is over its matching pair. Also reduce the delay of it to =0= so it will be instant.
#+begin_src emacs-lisp :tangle lisp/kpav-defaults.el
  (use-package paren
    :straight (:type built-in)
    :custom
    (show-paren-delay 0)
    :config
    (show-paren-mode +1))
#+end_src

*** Files
Emacs likes to create lots of extra files for things, these settings prevent that. Also, create a newline at the end of the file on save.
#+begin_src emacs-lisp :tangle lisp/kpav-defaults.el
  (use-package files
    :straight (:type built-in)
    :custom
    (make-backup-files nil)    ;; stop creating backup~ files
    (auto-save-default nil)    ;; stop creating #autosave# files
    (create-lockfiles nil)     ;; stop creating .# files
    (require-final-newline t)) ;; auto add newline at the end of file
#+end_src

When you visit a file, point goes to the last place where it was when you previously visited the same file.
#+begin_src emacs-lisp :tangle lisp/kpav-defaults.el
  (use-package saveplace
    :straight (:type built-in)
    :config
    (save-place-mode +1))
#+end_src

*** Whitespace
Show whitespace and newlines.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-defaults.el
  (use-package emacs
    :straight (:type built-in)
    :gfhook
    ('(prog-mode-hook org-mode-hook)
     (lambda ()
       (setq show-trailing-whitespace t
             indicate-buffer-boundaries 'left))))
#+end_src

Periods should be followed by a single space, not double spaces
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-defaults.el
  (use-package emacs
    :straight (:type built-in)
    :config
    (setq sentence-end-double-space nil))
#+end_src

Use spaces for indentation, not tabs. Set the width to 4 instead of the default of 8.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-defaults.el
  (use-package emacs
    :straight (:type built-in)
    :config
    (setq-default indent-tabs-mode nil
                  tab-width 4))
#+end_src

*** Auto Saving
#+begin_quote
super-save auto-saves your buffers, when certain events happen - e.g. you switch between buffers, an Emacs frame loses focus, etc.
#+end_quote

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-defaults.el
  (use-package super-save
    :straight t
    :init
    :config
    (add-to-list 'super-save-triggers 'ace-window)
    (super-save-mode +1))
#+end_src
*** EOF
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-defaults.el
  (provide 'kpav-defaults)
  ;;; kpav-defaults.el ends here
#+end_src
** Evil Mode
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-evil.el
  ;;; kpav-evil.el --- -*- lexical-binding: t -*-
#+end_src

Evil mode is vim in Emacs! Using =undo-fu= here instead of =undo-tree= as I have found that =undo-fu= seems to be quicker and less buggy than =undo-tree=.
#+begin_src emacs-lisp :tangle lisp/kpav-evil.el
  (use-package evil
    :straight t
    :general
    ;; make <tab> expand things in org mode for evil
    (general-nmap org-mode-map
      "<tab>" 'org-cycle)
    :init
    (use-package undo-fu :straight t)
    (setq evil-want-keybinding nil ;; evil-collection assumes this
          evil-undo-system 'undo-fu
          evil-disable-insert-state-bindings t) ;; emacs keys in insert mode
    :config
    (evil-mode +1))
#+end_src
The bit about using Emacs keybinds in evil mode is from https://stackoverflow.com/questions/25542097/emacs-evil-mode-how-to-change-insert-state-to-emacs-state-automatically

Use evil keys in various modes..
#+begin_src emacs-lisp :tangle lisp/kpav-evil.el
  (use-package evil-collection
    :straight t
    :after evil
    :config
    (evil-collection-init))
#+end_src

surround.vim emulation.
#+begin_src emacs-lisp :tangle lisp/kpav-evil.el
  (use-package evil-surround
    :straight t
    :after evil
    :config
    (global-evil-surround-mode +1))
#+end_src

vim-commentary emulation
#+begin_src emacs-lisp :tangle lisp/kpav-evil.el
  (use-package evil-commentary
    :straight t
    :config
    (evil-commentary-mode +1))
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-evil.el
  (provide 'kpav-evil)
  ;;; kpav-evil.el ends here
#+end_src
** Keys
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-keys.el
  ;;; kpav-keys.el --- -*- lexical-binding: t -*-
#+end_src

Press any two keys for keybinds.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-keys.el
  (use-package key-chord
    :straight t
    :config
    (key-chord-mode +1))
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-keys.el
  (provide 'kpav-keys)
  ;;; kpav-keys.el ends here
#+end_src
** UI
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-ui.el
  ;;; kpav-ui.el --- -*- lexical-binding: t -*-
#+end_src
*** Fonts
Set up fonts, This sets up the =default= typeface, and the ones to be used in [[*Variable Pitch][variable-pitch-mode,]] =variable-pitch= and =fixed-pitch=.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-ui.el
  (use-package faces
    :straight (:type built-in)
    :init
    ;; Main typeface
    ;; (set-face-attribute 'default nil :family "Iosevka" :height 130)
    (set-face-attribute 'default nil :family "Recursive Mn Lnr St" :height 130)
    ;; Proportionately spaced typeface
    ;; (set-face-attribute 'variable-pitch nil :family "EtBembo" :height 1.0)
    (set-face-attribute 'variable-pitch nil :family "Recursive Sn Lnr St" :height 1.0)
    ;; Monospaced typeface
    ;; (set-face-attribute 'fixed-pitch nil :family "Iosevka" :height 1.0))
    (set-face-attribute 'fixed-pitch nil :family "Recursive Mn Lnr St" :height 1.0))
#+end_src

Increase the line spacing to let the text breathe a bit.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-ui.el
  (use-package emacs
    :straight (:type built-in)
    :init
    (setq-default line-spacing 3))
#+end_src

*** Modus Themes
#+begin_quote
Accessible themes for GNU Emacs, conforming with the highest standard for colour contrast between background and foreground values (WCAG AAA)
#+end_quote

Modus themes are readable, clean looking, and super customizable. It also works very well with Org mode and Variable Pitch.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-ui.el
  (use-package modus-themes
    :straight t
    :init
    (setq modus-themes-mixed-fonts t
          modus-themes-bold-constructs t
          modus-themes-italic-constructs t
          modus-themes-intense-markup t
          modus-themes-completions '((matches . (extrabold background intense underline))
                                     (selection . (semibold background intense accented))
                                     (popup . (accented)))
          modus-themes-subtle-line-numbers t
          modus-themes-syntax '(faint alt-syntax)
          modus-themes-paren-match '(bold intense underline)
          modus-themes-region '(accented no-extend)
          modus-themes-mode-line '(borderless)
          ;; org specific settings
          modus-themes-org-blocks 'gray-background
          modus-themes-headings '((1 . (1.4))
                                  (2 . (1.2))
                                  (3 . (1.1))
                                  (t . (semibold)))
          modus-themes-scale-headings t)
    (modus-themes-load-themes)
    :config
    (modus-themes-load-vivendi))
#+end_src
*** Variable Pitch
=variable-pitch-mode= allows us to have multiple fonts in a single buffer. This is useful for =org-mode= which can have prose, code, and other things, in the same file.

Turn =variable-pitch-mode= on for =org-mode=.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-ui.el
  (use-package face-remap
    :straight (:type built-in)
    :gfhook
    ('org-mode-hook #'variable-pitch-mode))
#+end_src
*** Modeline
Set up for =doom-modeline=. Nice looking modeline that plays well with evil and lots of other stuff.

You need to run =M-x all-the-icons-install-fonts= to get the fancy fonts in the modeline

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-ui.el
  (use-package all-the-icons
    :straight t
    :defer t)
#+end_src

=column-number-mode= displays the cursors current line on the modeline
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-ui.el
  (use-package doom-modeline
    :straight t
    :demand t
    :preface
    :init
    (column-number-mode +1)
    (doom-modeline-mode +1)
    :custom
    (doom-modeline-vcs-max-length 50)
    (doom-modeline-buffer-file-name-style 'truncate-upto-project)
    (doom-modeline-modal-icon t)
    (doom-modeline-buffer-encoding nil)
    (doom-modeline-indent-info nil))
#+end_src
*** Rainbow Delimiters
Add rainbow delimiters in all programming language modes
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-ui.el
  (use-package rainbow-delimiters
    :straight t
    :ghook
    ('prog-mode-hook #'rainbow-delimiters-mode))
#+end_src
*** Cursor
Don't blink the cursor.
#+begin_src emacs-lisp :tangle lisp/kpav-ui.el
  (use-package frame
    :straight (:type built-in)
    :config
    (blink-cursor-mode -1))
#+end_src

Highlight the line the cursor is on.
#+begin_src emacs-lisp :tangle lisp/kpav-ui.el
  (use-package hl-line
    :straight (:type built-in)
    :config
    (global-hl-line-mode +1))
#+end_src
*** EOF
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-ui.el
  (provide 'kpav-ui)
  ;;; kpav-ui.el ends here
#+end_src
** Windows and Buffers
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-windows-and-buffers.el
  ;;; kpav-windows-and-buffers.el --- -*- lexical-binding: t -*-
#+end_src
*** Keys
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-windows-and-buffers.el
  (use-package window
    :straight (:type built-in)
    :general
    (base-leader-def
     :states 'normal
     "b" '(:ignore t :wk "buffers")
     "w" '(:ignore t :wk "windows")
     ;; "bb" 'switch-to-buffer
     ;; "bb" 'consult-buffer
     ;; "bk" 'kill-buffer
     "wo" 'split-window-horizontally
     "wu" 'split-window-vertically
     "wd" 'delete-window))
#+end_src
*** Navigation
Windmove provides a way to move around emacs windows.

Default keybindings are: ~S-arrowkey~ (e.g. ~S-Left~) to move around
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-windows-and-buffers.el
  (use-package windmove
    :straight (:type built-in)
    :general
    (base-leader-def
     :states 'normal
     "wh" 'windmove-left
     "wj" 'windmove-down
     "wk" 'windmove-up
     "wl" 'windmove-right)
    :config
    (windmove-default-keybindings))
#+end_src

ace-window lets you jump around windows with a single key
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-windows-and-buffers.el
  (use-package ace-window
    :straight t
    :general
    ("M-o" 'ace-window)
    (base-leader-def
      :states 'normal
      "ww" 'ace-window)
    :custom
    ;; use home row instead of numbers
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+end_src
*** COMMENT eyebrowse
Eyebrowse provides a way to manage workspaces like tiling window managers.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-windows-and-buffers.el
  (use-package eyebrowse
    :straight t
    :general
    (base-leader-def
      :states 'normal
      "w." 'eyebrowse-switch-to-window-config
      "w," 'eyebrowse-rename-window-config
      "w1" 'eyebrowse-switch-to-window-config-1
      "w2" 'eyebrowse-switch-to-window-config-2
      "w3" 'eyebrowse-switch-to-window-config-3
      "w4" 'eyebrowse-switch-to-window-config-4
      "w4" 'eyebrowse-switch-to-window-config-4
      "w5" 'eyebrowse-switch-to-window-config-5
      "w6" 'eyebrowse-switch-to-window-config-6
      "w7" 'eyebrowse-switch-to-window-config-7
      "w8" 'eyebrowse-switch-to-window-config-8
      "w9" 'eyebrowse-switch-to-window-config-9
      "w0" 'eyebrowse-switch-to-window-config-0)
    :config
    (eyebrowse-mode t))
#+end_src
*** perspective
Default key is ~C-x x~. Change it with =perp-mode-prefix-key=
Each frame gets its own perspective.
Switch buffer command only looks at current perspective
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-windows-and-buffers.el
  (use-package perspective
    :straight t
    :custom
    (persp-suppress-no-prefix-key-warning t)
    :general
    (base-leader-def
      :states 'normal
      "b`" 'persp-switch-by-number
      "bb" 'persp-switch-to-buffer
      "bk" 'persp-remove-buffer
      "bc" 'persp-kill
      "br" 'persp-rename
      "ba" 'persp-add-buffer
      "bA" 'persp-set-buffer
      "bi" 'persp-import
      "bn" 'persp-next
      "bp" 'persp-prev
      "bm" 'persp-merge
      "bu" 'persp-unmerge
      "bg" 'persp-add-buffer-to-frame-global
      "b C-s" 'persp-state-save
      "b C-l" 'persp-state-load
      "bs" 'persp-switch)
    :config
    (persp-mode +1))
#+end_src
*** EOF
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-windows-and-buffers.el
  (provide 'kpav-windows-and-buffers)
  ;;; kpav-windows-and-buffers.el ends here
#+end_src
** Org Mode
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-org.el
  ;;; kpav-org.el --- -*- lexical-binding: t -*-
#+end_src

- Use evil way of closing and quitting (=:q= =:x=) when editing code in org mode
- Define some keys
- Disable the checkdock check because most of my elisp code is in snippets in this config
- =org-use-fast-todo-selection=
  - Change the status of the todo state by pressing ~C-c C-c t <KEY>~
  - the =<KEY>= is the the letter in the parens after the state (e.g. =TODO(t)=)

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-org.el
  (use-package org
    :straight t
    :general
    (org-src-mode-map
     [remap evil-save-and-close] 'org-edit-src-exit
     [remap evil-save-modified-and-close] 'org-edit-src-exit
     [remap evil-quit] 'org-edit-src-abort)
    (base-leader-def
      :states 'normal
      "a" 'org-agenda)
    (base-local-leader-def
      :keymaps 'org-mode-map
      :states 'normal
      "b" 'org-babel-tangle)
    :preface
    (defun my-disable-flycheck-for-elisp ()
      (setq flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
    :gfhook
    ('org-src-mode-hook #'my-disable-flycheck-for-elisp)
    #'visual-line-mode
    :init
    (setq org-startup-indented t)
    :custom
    (org-agenda-files (list "~/org/agenda/"))
    (org-use-fast-todo-selection t)
    (org-todo-keywords
     '((sequence "TODO(t)" "NEXT(n)" "CURRENT(c)" "|" "DONE(d)")
       (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(a@/!)")))
    ;; Styling
    (org-auto-align-tags nil)
    (org-tags-column 0)
    (org-hide-emphasis-markers t)
    (org-pretty-entities t)
    (org-ellipsis "â€¦"))
#+end_src

Install =org-contrib=
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-org.el
  (use-package org-contrib
    :straight t)
#+end_src

Prettify headings and lists with =org-superstar-mode=
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-org.el
  (use-package org-superstar
    :straight t
    :ghook
    ('org-mode-hook (lambda () (org-superstar-mode +1))))
#+end_src

Capture Templates
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-org.el
  (use-package org-capture
    :straight nil
    :general
    (base-leader-def
      :states 'normal
      "C" 'org-capture)
    :custom
    (org-capture-templates
     '(("t" "Todo" entry (file+headline "~/org/agenda/todo.org" "Tasks")
        "* TODO %?\n %i\n %^{LINK}p")
       ("g" "Grow Log" entry (file+olp+datetree "~/grow/grow.org" "Log")
        "* Day Xn\n** Log\n** Notes\n %?\n %i\n"))))
#+end_src
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-org.el
  (provide 'kpav-org)
  ;;; kpav-org.el ends here
#+end_src
** Narrowing
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-narrowing.el
  ;;; kpav-narrowing.el --- -*- lexical-binding: t -*-
#+end_src
Set up Vertico and various packages that play well with it.
*** Vertico
Vertico comes with several extensions in an =extensions/= folder. These don't get automatically loaded with =:straight t=, so it needs a custom recipe.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-narrowing.el
  (use-package vertico
    :straight (vertico :files (:defaults "extensions/*")
                       :includes (vertico-buffer
                                  vertico-directory
                                  vertico-flat
                                  vertico-indexed
                                  vertico-mouse
                                  vertico-quick
                                  vertico-repeat
                                  vertico-reverse))
    :init
    (vertico-mode +1))
#+end_src

The multiform extension allows configuration per command. Using reverse by default, which I like because what you type does not move positions. Using buffer for ripgrep results as the list could be long.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-narrowing.el
  (use-package vertico-multiform
    :custom
    ;; (vertico-buffer-display-action
    ;;  (const :tag "Bottom of frame"
    ;;         (display-buffer-at-bottom
    ;;          (window-height . ,(+ 3 vertico-count)))))
    (vertico-multiform-commands
     '(;; (consult-ripgrep buffer)
       (t reverse)))
    :init
    (vertico-multiform-mode +1))
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-narrowing.el
  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :straight (:type built-in)
    :init
    (savehist-mode +1))

  ;; A few more useful configurations...
  (use-package emacs
    :straight (:type built-in)
    :init
    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    (setq read-extended-command-predicate
          #'command-completion-default-include-p)
    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))
#+end_src
*** Orderless
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-narrowing.el
  (use-package orderless
    :straight t
    :init
    (setq completion-styles '(orderless)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+end_src
*** ctrlf
#+begin_quote
a from scratch redesigned buffer-search interface
#+end_quote

A replacement for the built in I-Search. This replaces the evil search and the built in search. The bit in =general= handles evil and =ctrlf-mode= automatically redefines =C-s=.
- ~C-s~ - forward search
- ~C-r~ - backward search
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-narrowing.el
  (use-package ctrlf
    :straight t
    :general
    (evil-normal-state-map "/" 'ctrlf-forward-fuzzy-regexp)
    :init
    (ctrlf-mode +1))
#+end_src
*** Marginalia
Marginalia adds information to the completions provided by Selectrum (keybinds, info about command, etc.)
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-narrowing.el
  (use-package marginalia
    :straight t
    :general
    ("M-A" 'marginalia-cycle)
    (:keymaps
     'minibuffer-local-map
     "M-A" 'marginalia-cycle)
    :init
    (marginalia-mode +1))
#+end_src
*** Consult
#+begin_quote
Consult provides practical commands based on the Emacs completion function completing-read.
#+end_quote
Keys copied from projects README.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-narrowing.el
  (use-package consult
    :after projectile ;; needed to set `consult-project-root-function'
    :straight t
    :general
    ;; C-c bindings (mode-specific-map)
    ("C-c h" 'consult-history)
    ("C-c m" 'consult-mode-command)
    ("C-c b" 'consult-bookmark)
    ("C-c k" 'consult-kmacro)
    ;; C-x bindings (ctl-x-map)
    ("C-x M-:" 'consult-complex-command)     ;; orig. repeat-complex-command
    ("C-x b" 'consult-buffer)                ;; orig. switch-to-buffer
    ("C-x 4 b" 'consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
    ("C-x 5 b" 'consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
    ;; Custom M-# bindings for fast register access
    ("M-#" 'consult-register-load)
    ("M-'" 'consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
    ("C-M-#" 'consult-register)
    ;; Other custom bindings
    ("M-y" 'consult-yank-pop)                ;; orig. yank-pop
    ("<help> a" 'consult-apropos)            ;; orig. apropos-command
    ;; M-g bindings (goto-map)
    ("M-g e" 'consult-compile-error)
    ("M-g f" 'consult-flycheck)              ;; Alternative: consult-flycheck
    ("M-g g" 'consult-goto-line)             ;; orig. goto-line
    ("M-g M-g" 'consult-goto-line)           ;; orig. goto-line
    ("M-g o" 'consult-outline)               ;; Alternative: consult-org-heading
    ("M-g m" 'consult-mark)
    ("M-g k" 'consult-global-mark)
    ("M-g i" 'consult-imenu)
    ("M-g I" 'consult-imenu-multi)
    ;; M-s bindings (search-map)
    ("M-s f" 'consult-find)
    ("M-s F" 'consult-locate)
    ("M-s g" 'consult-grep)
    ("M-s G" 'consult-git-grep)
    ("M-s r" 'consult-ripgrep)
    ("M-s l" 'consult-line)
    ("M-s L" 'consult-line-multi)
    ("M-s m" 'consult-multi-occur)
    ("M-s k" 'consult-keep-lines)
    ("M-s u" 'consult-focus-lines)
    ;; Isearch integration
    ("M-s e" 'consult-isearch)
    (:keymaps
     'isearch-mode-map
     "M-e" 'consult-isearch                 ;; orig. isearch-edit-string
     "M-s e" 'consult-isearch               ;; orig. isearch-edit-string
     "M-s l" 'consult-line                  ;; needed by consult-line to detect isearch
     "M-s L" 'consult-line-multi)           ;; needed by consult-line to detect isearch
    :init
    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    ;; (advice-add #'register-preview :override #'consult-register-window)

    ;; Optionally replace `completing-read-multiple' with an enhanced version.
    (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
    :config
    ;; projectile
    ;; for this ti work, either need to autoload it, or use :after projectile
    ;; (autoload 'projectile-project-root "projectile")
    (setq consult-project-root-function #'projectile-project-root)
    ;; project.el
    ;; (setq consult-project-root-function
    ;;       (lambda ()
    ;;         (when-let (project (project-current))
    ;;           (car (project-roots project)))))
    )
#+end_src
*** Embark
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-narrowing.el
  (use-package embark
    :straight t
    :general
    ;; ("C-'" 'embark-act)
    ;; ("C-;" 'embark-dwim)
    ("C-h B" 'embark-bindings)
    ("C-;" 'embark-act)
    ("C-h B" 'embark-bindings) ;; alternative for `describe-bindings'
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :straight t
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :ghook
    ('embark-collect-mode #'consult-preview-at-point-mode))
#+end_src
*** COMMENT Selectrum
Selectrum is a narrowing/completion system similiar to Ivy.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-narrowing.el
  (use-package selectrum
    :straight t
    :demand t
    :ghook
    'after-init-hook)
#+end_src
*** COMMENT Prescient
#+begin_quote
Filter and sort results ... by frecency (a combination of frequency and recency).
#+end_quote
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-narrowing.el
  (use-package prescient
    :straight t
    :after selectrum
    :config
    (prescient-persist-mode +1))

  (use-package selectrum-prescient
    :straight t
    :after (selectrum prescient)
    :init
    (selectrum-prescient-mode +1))
#+end_src
*** EOF
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-narrowing.el
  (provide 'kpav-narrowing)
  ;;; kpav-narrowing.el ends here
#+end_src
** System Specific
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-system.el
  ;;; kpav-system.el --- -*- lexical-binding: t -*-
#+end_src

Ensure that Emacs uses the correct environment. This is especially useful for OSX, as Emacs may inherit a default set of environment variables, not the ones that you see in a terminal.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-system.el
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns x))
    :straight t
    :config
    (exec-path-from-shell-initialize))
#+end_src

The =railwaycat/emacs-mac= port maps the command key to meta, I like it bound to super because it matches my external keyboard better.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-system.el
  (use-package emacs
    :straight (:type built-in)
    :if (eq system-type 'darwin)
    :custom
    (mac-option-modifier 'meta)
    (mac-command-modifier 'super))
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-system.el
  (provide 'kpav-system)
  ;;; kpav-system.el ends here
#+end_src
** Random
Make ~ESC~ close any prompts
#+begin_src emacs-lisp :lexical t :tangle init.el
  (use-package emacs
    :straight (:type built-in)
    :general
    ("<escape>" 'keyboard-escape-quit))
#+end_src

Stop warnings buffer from automatically coming up. (Emacs 28)
#+begin_src emacs-lisp :lexical t :tangle init.el
  (use-package emacs
    :straight (:type built-in)
    :init
    (setq native-comp-async-report-warnings-errors nil))
#+end_src

Get list of minor modes in current buffer
#+begin_src emacs-lisp :lexical t :tangle init.el
  (defun kpav/minor-modes ()
    (interactive)
    (completing-read
     "Minor modes: "
     local-minor-modes
     nil t))
#+end_src
* Tools
Add and configure some additional tools.
** Git
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-git.el
  ;;; kpav-git.el --- -*- lexical-binding: t -*-
#+end_src
I only use =git= for version control, and I assume most  others do as well. This is probably why there are so many great =git= packages for Emacs!
*** magit
Magit may be one of the best front ends for =git= ever. It makes using git, both the simple and complex parts of it, easy and intuitive to use, right within Emacs! It also provides some neat stuff like =spinoff=, which will create a branch of any unpushed commits. This is handy if you accidentally starting commiting work to the wrong branch, e.g. =master= or =develop=.

I have a function here which copies the current branch name. This is handy if you need the branch name for something like a CI/CD system.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-git.el
  (use-package magit
    :straight t
    :defer t
    :general
    ("C-x g" 'magit-status)
    (base-leader-def
      :states 'normal
      "g" '(:ignore t :wk "git")
      "gs" 'magit-status
      "gc" 'magit-checkout
      "gC" 'magit-commit
      "gb" 'magit-blame
      "gS" 'magit-stage-file
      "gU" 'magit-unstage-file
      "gy" 'kpav/magit-yank-branch-name)
    :config
    (defun kpav/magit-yank-branch-name ()
      "Show the current branch in the echo-area and add it to the `kill-ring'."
      (interactive)
      (let ((branch (magit-get-current-branch)))
        (if branch
            (progn (kill-new branch)
                   (message "%s" branch))
          (user-error "There is not current branch")))))
#+end_src
*** git-gutter-fringe
Add git change icons in the fringe, e.g. when somethings been added, changed, or removed. Modus themes makes this look decent.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-git.el
  (use-package git-gutter-fringe
    :straight t
    :config
    (global-git-gutter-mode +1)
    (setq-default fringes-outside-margins t))
#+end_src
*** git-timemachine
Go through commit history on a file.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-git.el
  (use-package git-timemachine
    :straight t
    :defer t
    :general
    (base-leader-def
      :states 'normal
      "gt" 'git-timemachine))
#+end_src
*** git-link
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-git.el
  (use-package git-link
    :straight t
    :general
    (base-leader-def
      :states 'normal
      "gl" '(:ignore t :wk "git link")
      "gll" 'git-link
      "glc" 'git-link-commit
      "glh" 'git-link-homepage))
#+end_src
*** EOF
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-git.el
  (provide 'kpav-git)
  ;;; kpav-git.el ends here
#+end_src
** Projects
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-project.el
  ;;; kpav-project.el --- -*- lexical-binding: t -*-
#+end_src
A large part of my workflow is working in projects, which may or may not interact together, so I like to only open and interact with files and buffers on a per project basis. I use =perspective= to create perspectives for each project, then use the following packages to further interact with them, e.g. opening files or searching for some specific text.
*** project.el + projectile
Using a combination of the built-in =project.el= along with projectile. =project.el= works with marginalia to give extra info about files and buffers that projectile does not.

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-project.el
  (use-package project
    ;;:straight (:type built-in)
    :straight t
    :general
    (base-leader-def
     :states 'normal
     "p" '(:ignore t :wk "projects")
     "pf" 'project-find-file
     "pb" 'project-switch-to-buffer))

  (use-package projectile
    :straight t
    :init
    (use-package ripgrep :straight t)
    :general
    (base-leader-def
     :states 'normal
     "p" '(:ignore t :wk "projects")
     "pd" 'projectile-find-dir
     "pp" 'projectile-switch-project
     "pP" 'projectile-switch-open-project
     "pg" 'consult-ripgrep
     "pG" 'consult-git-grep)
    :config
    (projectile-mode +1))
#+end_src
*** Treemacs
Treemacs provides a nice file explorer for projects.

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-project.el
  (use-package treemacs
    :straight t
    :defer t
    :general
    ([f8] 'treemacs)
    (base-leader-def
      :states '(normal)
      "po" 'treemacs))

  (use-package treemacs-evil
    :straight t
    :after (evil treemacs))

  (use-package treemacs-magit
    :straight t
    :after (treemacs magit))
#+end_src
*** Direnv
Provide =direnv= support for projects with =.envrc= files.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-project.el
  (use-package envrc
    :straight t
    :config
    (envrc-global-mode +1))
#+end_src

Use =envrc-allow= to explicitly run =direnv allow=.
*** Editorconfig
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-project.el
  (use-package editorconfig
    :straight t
    :config
    (editorconfig-mode +1))
#+end_src
*** EOF
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-project.el
  (provide 'kpav-project)
  ;;; kpav-project.el ends here
#+end_src
** Terminal
*** vterm
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-vterm.el
  ;;; kpav-vterm.el --- -*- lexical-binding: t -*-
#+end_src

This provides a terminal emulator powered by libvterm. It is essentially a full terminal emulator.

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-vterm.el
  (use-package vterm
    :straight t)
#+end_src

Open multiple vterms. Evil configuration from it's README.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-vterm.el
  (use-package multi-vterm
    :straight t
    :general
    (base-leader-def
     :states 'normal
     "t" '(:ignore t :wk "term")
     "tt" 'multi-vterm
     "tn" 'multi-vterm-next
     "tp" 'multi-vterm-prev)
    :gfhook #'evil-insert-state
    :config
    (define-key vterm-mode-map [return]                      #'vterm-send-return)
    (setq vterm-keymap-exceptions nil)
    (evil-define-key 'insert vterm-mode-map (kbd "C-e")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-f")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-a")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-v")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-b")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-w")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-u")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-d")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-n")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-m")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-p")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-j")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-k")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-r")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-t")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-g")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-c")      #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-SPC")    #'vterm--self-insert)
    (evil-define-key 'normal vterm-mode-map (kbd "C-d")      #'vterm--self-insert)
    (evil-define-key 'normal vterm-mode-map (kbd ",c")       #'multi-vterm)
    (evil-define-key 'normal vterm-mode-map (kbd ",n")       #'multi-vterm-next)
    (evil-define-key 'normal vterm-mode-map (kbd ",p")       #'multi-vterm-prev)
    (evil-define-key 'normal vterm-mode-map (kbd "i")        #'evil-insert-resume)
    (evil-define-key 'normal vterm-mode-map (kbd "o")        #'evil-insert-resume)
    (evil-define-key 'normal vterm-mode-map (kbd "<return>") #'evil-insert-resume))
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-vterm.el
  (provide 'kpav-vterm)
  ;;; kpav-vterm.el ends here
#+end_src
** Docker
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-docker.el
  ;;; kpav-docker.el --- -*- lexical-binding: t -*-
#+end_src

Get syntax highlighting for =Dockerfile= files
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-docker.el
  (use-package dockerfile-mode
    :straight t
    :defer t)
#+end_src

Use =docker= commands in Emacs
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-docker.el
  (use-package docker
    :straight t
    :defer t)
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-docker.el
  (provide 'kpav-docker)
  ;;; kpav-docker.el ends here
#+end_src
* Code
Things that modify coding stuff (mostly programming langs and LSP).
** General
Things that can be used across all languages.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-code.el
  ;;; kpav-code.el --- -*- lexical-binding: t -*-
#+end_src

*** Code Completion
#+begin_quote
Company is a text completion framework for Emacs.
#+end_quote

=company= is essentially the standard package that is used for code completion. It works decently out of the box, has backends for nearly all languages, and is integrated with LSP.

#+begin_src emacs-lisp :tangle lisp/kpav-code.el
  (use-package company
    :straight t
    :config
    (global-company-mode +1))
#+end_src

*** Error Checking - Flymake
FlyMake is the built-in syntax checker for Emacs. It works for all (most?) of the languages that I use. Trying this out instead of *Flycheck* in my move to stick to built-in packages.

#+begin_src emacs-lisp :tangle lisp/kpav-code.el
  (use-package flymake
    :straight t
    :ghook
    ('prog-mode-hook #'flymake-mode-on))
#+end_src
*** COMMENT Error Checking - Flycheck
#+begin_quote
Flycheck is a modern on-the-fly syntax checking extension for GNU Emacs
#+end_quote

Flycheck works out of the box for just about everything and is integrated with lots of other packages.

#+begin_src emacs-lisp :tangle lisp/kpav-code.el
  (use-package flycheck
    :straight t
    :config
    (global-flycheck-mode +1))
#+end_src
*** Snippets
#+begin_quote
YA Snippet is a template system for Emacs.
#+end_quote

Set the snippets directory to be in this folder, automatically create it if it does not exist.
#+begin_src emacs-lisp :tangle lisp/kpav-code.el
  (use-package yasnippet
    :straight t
    :preface
    (defconst basemacs-snippets-dir (expand-file-name "snippets/" user-emacs-directory))
    (make-directory basemacs-snippets-dir :parents)
    :custom
    (yas-snippet-dirs (list basemacs-snippets-dir))
    :config
    (yas-global-mode +1))
#+end_src

Install the official snippet collection, this contains snippets for several programming languages.
#+begin_src emacs-lisp :tangle lisp/kpav-code.el
  (use-package yasnippet-snippets
    :straight t
    :after yasnippet)
#+end_src
*** Eglot
#+BEGIN_QUOTE
Emacs Polyglot: an Emacs LSP client that stays out of your way:
#+END_QUOTE

A simple (compared to =lsp-mode=) way to use Language Servers in Emacs. It uses built-in commands (e.g. =xref-find-definitions=) and packages (e.g. =flymake=).

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-code.el
  (use-package eglot
    :straight t
    :general
    (base-leader-def
      :states '(normal visual)
      "l" '(:ignore :wk "lsp")
      "lg" 'xref-find-definitions
      "lr" 'xref-find-references
      "lf" 'eglot-format
      "lF" 'eglot-format-buffer
      "la" 'eglot-code-actions
      "lo" 'eglot-code-actions-organize-imports
      "lh" 'eldoc))
#+end_src

Although Eglot depends on built-in packages, it needs the newest versions of them.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-code.el
  (use-package eldoc
    :straight t)

  (use-package xref
    :straight t)
#+end_src
*** COMMENT LSP
#+BEGIN_QUOTE
The Language Server Protocol (LSP) defines the protocol used between an editor or IDE and a language server that provides language features like auto complete, go to definition, find all references etc.
#+END_QUOTE

Setup for Microsoft's (GASP!) Language Server Protocol. Any language that uses this calls =lsp= in the language mode's =:hook= / =:ghook=.

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-code.el
  (use-package lsp-mode
    :straight t
    :gfhook
    #'lsp-enable-which-key-integration
    :commands lsp
    :init
    (setq lsp-completion-provider :capf
          lsp-keymap-prefix "C-l")
    :custom
    ;; I don't find the headerline very helpful,
    ;; the modeline shows most of it anyway
    (lsp-headerline-breadcrumb-enable nil))

  (use-package lsp-ui
    :straight t
    :commands lsp-ui-mode
    :custom
    (lsp-ui-sideline-show-code-actions nil))

  (use-package lsp-treemacs
    :straight t
    :commands lsp-treemacs-errors-list)

  (use-package dap-mode
    :straight t
    :defer t)
#+end_src

Some handy links
- https://emacs-lsp.github.io/lsp-mode/page/performance/
*** EOF
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-code.el
  (provide 'kpav-code)
  ;;; kpav-code.el ends here
#+end_src
** Languages (and more)
*** Lisps
**** Shared
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-lisp-core.el
  ;;; kpav-lisp-core.el --- -*- lexical-binding: t -*-
#+end_src

Lisps can share a lot of the same config code due to the nature of the syntax.

List of all lisp mode hooks. This is used to enable modes for all of them.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-lisp-core.el
  (defconst kpav-lisp-mode-hooks
    '(lisp-mode-hook
      ;; sly-mrepl-mode-hook
      emacs-lisp-mode-hook
      clojure-mode-hook
      ;; cider-repl-mode-hook
      ))
#+end_src

Lispy provides vim-like commands to navigate and edit Lisp code.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-lisp-core.el
  ;; (use-package lispy
  ;;   :straight t
  ;;   :ghook kpav-lisp-mode-hooks)

  ;; (use-package lispyville
  ;;   :straight t
  ;;   :ghook
  ;;   ('lispy-mode-hook #'lispyville-mode))
#+end_src

Symex provides even more vim-like commands (compared t0 lispy) to navigate and edit lisp code. Press ~C-'~ to start.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-lisp-core.el
  (use-package symex
    :straight t
    :custom
    (symex-modal-backend 'evil)
    :general
    ("C-'" 'symex-mode-interface)
    (:keymaps 'normal
              (general-chord "jk") 'symex-mode-interface)
    :config
    (symex-initialize))
#+end_src
This is a nice guide:
https://countvajhula.com/2021/09/25/the-animated-guide-to-symex/

Automatically indent code.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-lisp-core.el
  ;; (use-package aggressive-indent
  ;;   :straight t
  ;;   :ghook kpav-lisp-mode-hooks)
#+end_src
NOTE: commenting this out for now, useful for me, but not for work projects...too many whitespace changes.

Highlight whats being eval'ed
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-lisp-core.el
  (use-package eval-sexp-fu
    :straight t
    :ghook
    (kpav-lisp-mode-hooks #'eval-sexp-fu-flash-mode))
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-lisp-core.el
  (provide 'kpav-lisp-core)
  ;;; kpav-lisp-core.el ends here
#+end_src
**** Clojure
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-clojure.el
  ;;; kpav-clojure.el --- -*- lexical-binding: t -*-
  (require 'kpav-lisp-core)
#+end_src

Use =clj-condo= and =flycheck=. This needs to be loaded before =clojure-mode= (note that =clj-kondo= needs to be installed on the local machine!)
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-clojure.el
  (use-package flycheck-clj-kondo
    :straight t)
#+end_src

Use LSP with all clojure-related modes.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-clojure.el
  (use-package clojure-mode
    :straight t
    :defer t
    :ghook
    ;; ('clojure-mode-hook #'lsp)
    ;; ('clojurec-mode-hook #'lsp)
    ;; ('clojurescript-mode #'lsp)
    ('clojure-mode-hook #'eglot-ensure)
    ('clojurec-mode-hook #'eglot-ensure)
    ('clojurescript-mode #'eglot-ensure)
    ;; :custom
    ;; (lsp-enable-indentation nil)
    :config
    (require 'flycheck-clj-kondo))
  ;; is this needed?
  ;; :config
  ;; (dolist (m '(clojure-mode
  ;;              clojurec-mode
  ;;              clojurescript-mode
  ;;              clojurex-mode))
  ;;   (add-to-list 'lsp-language-id-configuration `(,m . "clojure")))
#+end_src

#+begin_quote
CIDER is the Clojure(Script) Interactive Development Environment that Rocks!
#+end_quote
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-clojure.el
  (use-package cider
    :straight t
    :after clojure-mode
    :ghook
    ('cider-repl-mode-hook #'rainbow-delimiters-mode)
    ;; ('cider-connected-hook #'cider-upgrade-nrepl-connection)
    :custom
    (cider-inject-dependencies-at-jack-in t)
    :general
    (base-local-leader-def
      :states '(normal visual)
      :keymaps 'clojure-mode-map
      "r" '(:ignore t :wk "repl")
      "rr" 'cider
      "rR" 'cider-restart
      "rn" 'cider-repl-set-ns
      "rb" 'cider-switch-to-repl-buffer
      "rc" 'cider-find-and-clear-repl-output
      "rl" 'cider-load-buffer
      "rq" 'cider-quit
      ;; eval
      "eD" 'cider-insert-defun-in-repl
      "eE" 'cider-insert-last-sexp-in-repl
      "eR" 'cider-insert-region-in-repl
      "eb" 'cider-eval-buffer
      "ed" 'cider-eval-defun-at-point
      "ee" 'cider-eval-last-sexp
      "er" 'cider-eval-region
      "eu" 'cider-undef
      "em" 'cider-macroexpand-1
      "eM" 'cider-macroexpand-all
      ;; help
      "h" '(:ignore t :wk "help")
      "ha" 'cider-apropos
      "hh" 'cider-doc
      "hj" 'cider-javadoc
      "hn" 'cider-browse-ns
      "hN" 'cider-browse-ns-all
      "hs" 'cider-browse-spec
      "hS" 'cider-browse-spec-all
      ;; inspect
      "i" '(:ignore t :wk "inspect")
      "ii" 'cider-inspect
      "ie" 'cider-enlighten-mode
      "ir" 'cider-inspect-last-result
      ;; pprint
      "p" '(:ignore t :wk "pprint")
      "pd" 'cider-pprint-eval-defun-at-point
      "pD" 'cider-pprint-eval-defun-to-comment
      "pD" 'cider-pprint-eval-last-sexp-to-repl
      ;; format
      "f" '(:ignore t :wk "format")
      "fr" 'cider-format-region
      "fb" 'cider-format-buffer
      "ff" 'cider-format-defun
      ;; goto
      "g" '(:ignore t :wk "goto")
      "gg" 'cider-find-var
      "gn" 'cider-find-ns
      "gN" 'cider-browse-ns-all
      "d" '(:ignore t :wk "debug")
      "dr" 'cider-ns-reload
      "dR" 'cider-ns-reload-all
      "di" 'cider-inspect-defun-at-point))
#+end_src

Refactoring functionality for Clojure.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-clojure.el
  (use-package clj-refactor
    :straight t
    :after cider
    :ghook
    ('clojure-mode-hook (lambda ()
                          (clj-refactor-mode +1)
                          (yas-minor-mode +1) ; for adding require/use/import statements
                          ;; Leaves cider-macroexpand-1 unbound
                          (cljr-add-keybindings-with-prefix "C-c C-m")))
    :general
    (base-local-leader-def
      :states '(normal visual)
      :keymaps 'clojure-mode-map
      "R" 'hydra-cljr-help-menu/body))
#+end_src

Highlight what's being eval'ed
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-clojure.el
  (use-package cider-eval-sexp-fu
    :straight t)
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-clojure.el
  (provide 'kpav-clojure)
  ;;; kpav-clojure.el ends here
#+end_src
**** Common Lisp
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-common-lisp.el
  ;;; kpav-common-lisp.el --- -*- lexical-binding: t -*-
  (require 'kpav-lisp-core)
#+end_src

Sly provides a Common Lisp REPL for Emacs.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-common-lisp.el
  (use-package sly
    :straight t
    :defer t
    :ghook
    ('sly-mrepl-mode-hook #'rainbow-delimiters-mode)
    :general
    (base-local-leader-def
     :states 'normal
     :keymaps 'lisp-mode-map
     "eb" 'sly-eval-buffer
     "el" 'sly-eval-last-expression
     "ed" 'sly-eval-defun
     "er" 'sly-eval-region)
    :custom
    (inferior-lisp-program "/usr/bin/sbcl"))

  (use-package sly-quicklisp
    :straight t
    :after sly)

  (use-package sly-asdf
    :straight t
    :after sly)
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-common-lisp.el
  (provide 'kpav-common-lisp)
  ;;; kpav-common-lisp.el ends here
#+end_src
**** Emacs Lisp
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-elisp.el
  ;;; kpav-elisp.el --- -*- lexical-binding: t -*-
  (require 'kpav-lisp-core)
#+end_src

Set up keys for evaling elisp.
#+BEGIN_src emacs-lisp :lexical t :tangle lisp/kpav-elisp.el
  (use-package emacs
    :straight (:type built-in)
    :general
    (base-local-leader-def
     :states 'normal
     :keymaps 'emacs-lisp-mode-map
     "e" '(:ignore t :wk "eval")
     "eb" 'eval-buffer
     "el" 'eval-last-sexp
     "ed" 'eval-defun
     "er" 'eval-region)
    (base-local-leader-def
     :states 'normal
     :keymaps 'lisp-interaction-mode-map
     "e" '(:ignore t :wk "eval")
     "eb" 'eval-buffer
     "el" 'eval-last-sexp
     "ed" 'eval-defun
     "er" 'eval-region))
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-elisp.el
  (provide 'kpav-elisp)
  ;;; kpav-elisp.el ends here
#+end_src
*** PHP
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-php.el
  ;;; kpav-php.el --- -*- lexical-binding: t -*-
#+end_src

I use PHP for my job, so I need to use the =WellspringCodingStandard=.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-php.el
  (use-package php-mode
    :straight t
    :mode "\\.php\\'"
    :gfhook #'my-php-setup
    :general
    (:keymaps 'php-mode-map
      "C-c a" 'my/align-php-dbl-arrow)
    :custom
    ;; align -> on successive lines
    (php-lineup-cascaded-calls t)
    (flycheck-phpcs-standard "WellspringCodingStandard"))
#+end_src

Setup the default coding style and LSP for php. Need to set =lsp-enable-file-watchers= to nil because the project has a large amount of files and it causes performance issues.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-php.el
  (defun my-php-setup ()
    (php-enable-default-coding-style)
    (setq lsp-enable-file-watchers nil)
    (lsp))
#+end_src

Align the ==>= in arrays
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-php.el
  (defun my/align-php-dbl-arrow ()
    "Align the => in arrays."
    (interactive)
    (align-regexp
     (region-beginning) (region-end)
     "\\(\\s-*\\) => " 1 0 nil))
#+end_src

Use =PHP_CodeSniffer= to format files
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-php.el
  (use-package phpcbf
    :straight t
    :after (php-mode)
    :custom
    (phpcbf-executable "/usr/local/bin/phpcbf")
    (phpcbf-standard "WellspringCodingStandard"))
#+end_src

=psysh= is a php repl
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-php.el
  (use-package psysh
    :straight t
    :defer t)
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-php.el
    (provide 'kpav-php)
    ;;; kpav-php.el ends here
#+end_src
*** JavaScript / TypeScript
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-js.el
  ;;; kpav-js.el --- -*- lexical-binding: t -*-
#+end_src
**** JavasScript
Using the built in =js-mode=. This handles both vanilla js and =.jsx=.
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-js.el
  (use-package js-mode
    :straight (:type built-in)
    :mode "\\.js\\'"
    :interpreter "node"
    :gfhook
    ;;#'lsp
    #'eglot-ensure)
#+end_src
**** TypeScript
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-js.el
  (use-package typescript-mode
    :straight t
    :mode "\\.ts\\'"
    :commands (typescript-mode)
    :gfhook
    ;;#'lsp
    #'eglot-ensure)
#+end_src
**** JSON
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-js.el
  (use-package json-mode
    :straight t
    :mode "\\.json\\'")
#+end_src
**** EOF
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-js.el
  (provide 'kpav-js)
  ;;; kpav-js.el ends here
#+end_src
*** C / C++
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-c.el
  ;;; kpav-c.el --- -*- lexical-binding: t -*-
#+end_src

Set up the =ccls= language server
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-c.el
  (use-package ccls
    :straight t
    :hook ((c-mode c++-mode objc-mode cuda-mode) .
           (lambda () (require 'ccls) (lsp)))
    :config
    (setq ccls-executable "/usr/bin/ccls")
    ;; use flycheck instead of flymake
    (setq lsp-prefer-flymake nil)
    (setq-default flycheck-disabled-checkers '(c/c++-clang c/c++-cppcheck c/c++-gcc)))
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-c.el
  (provide 'kpav-c)
  ;;; kpav-c.el ends here
#+end_src
*** YAML
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-yaml.el
  ;;; kpav-yaml.el --- -*- lexical-binding: t -*-
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-yaml.el
  (use-package yaml-mode
    :straight t
    :defer t)
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-yaml.el
  (provide 'kpav-yaml)
  ;;; kpav-yaml.el ends here
#+end_src
*** gRPC
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-grpc.el
  ;;; kpav-grpc.el --- -*- lexical-binding: t -*-
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-grpc.el
  (use-package protobuf-mode
    :straight t
    :defer t)
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-grpc.el
  (provide 'kpav-grpc)
  ;;; kpav-grpc.el ends here
#+end_src
*** GraphQL
#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-graphql.el
  ;;; kpav-graphql.el --- -*- lexical-binding: t -*-
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-graphql.el
  (use-package graphql-mode
    :straight t
    :defer t)
#+end_src

#+begin_src emacs-lisp :lexical t :tangle lisp/kpav-graphql.el
  (provide 'kpav-graphql)
  ;;; kpav-graphql.el ends here
#+end_src

* EOF
#+begin_src emacs-lisp :lexical t :tangle init.el
  (provide 'init)
  ;;; init.el ends here
#+end_src
* TODO To Do List
** TODO Test JS / TS stuff more
** TODO Add JS REPL (skewer?)
** TODO Add keys for LSP
jumping and stuff
** TODO Add Hydra
Should probably be in =basemacs-core=
** TODO Add keys for files, M-x, C-x?
e.g. ~SPC f~
** TODO Look into Selectrum and co. config more
See what other settings there are
** TODO Bookmark keys
** DONE Git keys
** TODO Look into TabNine / company-tabnine
AI completion engine?
** DONE Remove org from =basemacs-core= OR set :straight t
conflicts with other org customization
** DONE Remove magit from =basemacs-core=?
** TODO Look into Corfu to replace company
** TODO Use org-modern and make it look good
